// Code generated by mockery v2.22.1. DO NOT EDIT.

package mocks

import (
	allocationchange "github.com/0chain/gosdk/zboxcore/allocationchange"
	fileref "github.com/0chain/gosdk/zboxcore/fileref"

	mock "github.com/stretchr/testify/mock"

	sdk "github.com/0chain/gosdk/zboxcore/sdk"

	uuid "github.com/google/uuid"

	zboxutil "github.com/0chain/gosdk/zboxcore/zboxutil"
)

// Operationer is an autogenerated mock type for the Operationer type
type Operationer struct {
	mock.Mock
}

// Completed provides a mock function with given fields: allocObj
func (_m *Operationer) Completed(allocObj *sdk.Allocation) {
	_m.Called(allocObj)
}

// Error provides a mock function with given fields: allocObj, consensus, err
func (_m *Operationer) Error(allocObj *sdk.Allocation, consensus int, err error) {
	_m.Called(allocObj, consensus, err)
}

// Process provides a mock function with given fields: allocObj, connectionID
func (_m *Operationer) Process(allocObj *sdk.Allocation, connectionID string) ([]fileref.RefEntity, zboxutil.Uint128, error) {
	ret := _m.Called(allocObj, connectionID)

	var r0 []fileref.RefEntity
	var r1 zboxutil.Uint128
	var r2 error
	if rf, ok := ret.Get(0).(func(*sdk.Allocation, string) ([]fileref.RefEntity, zboxutil.Uint128, error)); ok {
		return rf(allocObj, connectionID)
	}
	if rf, ok := ret.Get(0).(func(*sdk.Allocation, string) []fileref.RefEntity); ok {
		r0 = rf(allocObj, connectionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]fileref.RefEntity)
		}
	}

	if rf, ok := ret.Get(1).(func(*sdk.Allocation, string) zboxutil.Uint128); ok {
		r1 = rf(allocObj, connectionID)
	} else {
		r1 = ret.Get(1).(zboxutil.Uint128)
	}

	if rf, ok := ret.Get(2).(func(*sdk.Allocation, string) error); ok {
		r2 = rf(allocObj, connectionID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Verify provides a mock function with given fields: allocObj
func (_m *Operationer) Verify(allocObj *sdk.Allocation) error {
	ret := _m.Called(allocObj)

	var r0 error
	if rf, ok := ret.Get(0).(func(*sdk.Allocation) error); ok {
		r0 = rf(allocObj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// buildChange provides a mock function with given fields: refs, uid
func (_m *Operationer) buildChange(refs []fileref.RefEntity, uid uuid.UUID) []allocationchange.AllocationChange {
	ret := _m.Called(refs, uid)

	var r0 []allocationchange.AllocationChange
	if rf, ok := ret.Get(0).(func([]fileref.RefEntity, uuid.UUID) []allocationchange.AllocationChange); ok {
		r0 = rf(refs, uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]allocationchange.AllocationChange)
		}
	}

	return r0
}

type mockConstructorTestingTNewOperationer interface {
	mock.TestingT
	Cleanup(func())
}

// NewOperationer creates a new instance of Operationer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewOperationer(t mockConstructorTestingTNewOperationer) *Operationer {
	mock := &Operationer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
